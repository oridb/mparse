use std

use "types"
use "tokdefs"
use "util"

pkg parse =
	const tokinit	: (path : byte[:]	-> parser#)
	const tokinitf	: (fd : std.fd, path : byte[:]	-> parser#)
	const tokclose	: (p : parser#	-> void)

	const toknextt	: (p : parser#	-> tok)
	const toknext	: (p : parser#	-> (srcloc, tok))
	const tokpeekt	: (p : parser#	-> tok)
	const tokpeek	: (p : parser#	-> (srcloc, tok))
	const tokunget	: (p : parser#	-> void)
;;

const Eof = std.Badchar

const tokinit = {path
	match std.slurp(path)
	| `std.Ok data: -> mkparser(path, data)
	| `std.Fail e:	std.fatal("could not read file {}: {}\n", path, e)
	;;
}

const tokinitf = {fd, name
	match std.fslurp(fd)
	| `std.Ok data: -> mkparser(name, data)
	| `std.Fail e:	std.fatal("could not read file {}: {}\n", fd, e)
	;;
}

const mkparser = {name, data
	-> std.mk([
		.loc = [.file=name, .line=1, .col=1],
		.next=`std.None,
		.rest=data,
		.data=data,
	])
}

const tokclose = {p
	std.slfree(p.data)
	std.free(p)
}

const toknext = {p
	var t
	match p.next
	| `std.Some tok:
		p.last = p.next
		p.next = `std.None
		-> tok
	| `std.None:
		t = tokread(p)
		p.last = `std.Some t
		-> t
	;;
}

const toknextt = {p
	match toknext(p)
	| (l, t):	-> t
	;;
}

const tokunget = {p
	p.next = p.last
}

const tokpeek = {p
	var tok

	match p.next
	| `std.Some t:
		-> t
	| `std.None:
		tok = tokread(p)
		p.next = `std.Some tok
		-> tok
	;;
}

const tokpeekt = {p
	match tokpeek(p)
	| (l, t):	-> t
	;;
}

const tokread = {p
	var c, loc, id

	skipspace(p)
	loc = p.loc
	c = peekc(p)
	if p.rest.len == 0
		-> (loc, `Teof)
	elif c == '\n'
		takec(p)
		p.loc.line++
		p.loc.col = 1
		-> (loc, `Tendln)
	elif c == '\''
		-> (loc, chrlit(p))
	elif c == '"'
		-> (loc, strlit(p))
	elif c == '@'
		-> (loc, typaram(p))
	elif std.isdigit(c)
		-> (loc, numlit(p))
	elif isident(c)
		id = kwident(p)
		-> (loc, id)
	else
		-> (loc, oper(p))
	;;
}

const skipspace = {p
	var ignorenl

	ignorenl = false
	while true
		match peekc(p)
		| '\n':
			if ignorenl
				takec(p)
				p.loc.line++
				p.loc.col = 1
			else
				break
			;;
		| '\\':
			ignorenl = true
			takec(p)
		| '/':
			match npeekc(p, 1)
			| '/':	skipto(p, '\n')
			| '*':	skipcomment(p)
			| _:	break
			;;
		| c:
			if std.isspace(c)
				takec(p)
			else
				break
			;;
		;;
	;;
}

const skipcomment = {p
	var depth, startln

	depth = 0
	startln = p.loc.line
	while true
		match takec(p)
		| '/':
			if matchc(p, '*')
				depth++
			;;
		| '*':
			if matchc(p, '/')
				depth--
			;;
		| '\n':
			p.loc.line++
			p.loc.col = 1
		| Eof:
			err(p.loc, "file ended in comment starting on line {}\n", startln)
		| _:
		;;

		if depth == 0
			break
		;;
	;;
}

const chrlit = {p
	var c, close

	takec(p)
	c = takec(p)
	if c == '\\'
		c = unescape(p)
	;;
	close = takec(p)
	if close != '\''
		err(p.loc, "expected closing ' in character literal, got {}\n", close)
	;;
	-> `Tchrlit c
}

const strlit = {p
	var sb

	takec(p)
	sb = std.mksb()
	while true
		match takec(p)
		| Eof:
			err(p.loc, "unexpected EOF within string literal\n")
		| '\n':
			err(p.loc, "unexpected \\n within string literal\n")
		| '"':
			break
		| '\\':
			std.sbputc(sb, unescape(p))
		| c:
			std.sbputc(sb, c)
		;;
	;;
	-> `Tstrlit std.sbfin(sb)
}

const unescape = {p
	var c, c1, c2

	c = takec(p)
	/* we've already seen the '\' */
	match c
	| 'n':	-> '\n'
	| 'r':	-> '\r'
	| 't':	-> '\t'
	| 'b':	-> '\b'
	| '"':	-> '\"'
	| '\'':	-> '\''
	| 'v':	-> '\v'
	| '\\':	-> '\\'
	| '0':	-> '\0'
	| 'u':	-> utfesc(p);
	| 'x':
		c1 = takec(p)
		if !std.isxdigit(c1)
			err(p.loc, "expected hex digit, got {}\n", c1)
		;;
		c2 = takec(p)
		if !std.isxdigit(c2)
			err(p.loc, "expected hex digit, got {}\n", c2)
		;;
		-> 16*std.charval(c1, 16) + std.charval(c2, 16)

		c2 = takec(p)
	| esc:
		err(p.loc, "unknown escape code \\{}\n", esc)
	;;
}

const utfesc = {p
	var c, v

	if takec(p) != '{'
		err(p.loc, "\\u escape sequence without initial '{'\n")
	;;
	v = 0
	c = std.Badchar
	while true
		c = takec(p)
		if std.isxdigit(c)
			v *= 16
			v += std.charval(c, 16)
		else
			break
		;;
		if v > 0x10FFFF
			err(p.loc, "invalid codepoint in \\u escape sequence\n")
		;;
	;;
	if c != '}'
		err(p.loc, "\\u escape sequence without closing '{'\n")
	;;
	-> v
}

const typaram = {p
	takec(p)
	match kwident(p)
	| `Tident id:
		-> `Ttyparam id
	| kw:
		err(p.loc, "'{}' used as type parameter\n", kw)
	;;

}

const numlit = {p
	var t

	if matchc(p, '0')
		if matchc(p, 'x')
			t = number(p, 16)
		elif matchc(p, 'b')
			t = number(p, 2)
		elif matchc(p, 'o')
			t = number(p, 8)
		else
			t = number(p, 10)
		;;
	else
		t = number(p, 10)
	;;
	-> t
}


/*
only deals with the body of the number. if we reach
this code, then it's guaranteed that we already have
a numerical value.
*/
const number = {p, base
	var buf, nbuf
	var isfloat, issigned
	var v, bits

	buf = p.rest
	nbuf = 0
	isfloat = false
	for var c = peekc(p); std.isxdigit(c) || c == '.' || c == '_'; c = peekc(p)
		takec(p)
		if c == '_'
			continue
		elif c == '.'
			isfloat = true
		else 
			v = std.charval(c, base)
			if v < 0
				err(p.loc, "digit {} out of range of base {}\n", c, base)
			;;
		;;
		nbuf++
	;;

	if isfloat
		if base != 10
			err(p.loc, "floats must be in base 10\n")
		;;
		std.fatal("unable to parse floats: fuck me\n")
		/*
		-> `Tfltlit std.flt64parse(buf[:n])
		*/
	else
		issigned = true
		if peekc(p) == 'u'
			takec(p)
			issigned = false
		;;

		match peekc(p)
		| 'l':	bits = 64
		| 'i':	bits = 32
		| 's':	bits = 16
		| 'b':	bits = 8
		| _:	bits = minbits(v, issigned)
		;;
		v = std.get(std.intparsebase(buf[:nbuf], base))
		/* guaranteed to be ok */
		-> `Tintlit (v, bits, issigned)
	;;
}

const minbits = {v, issigned
	/* the range of signed values is effectively half unsigned */
	if issigned
		v *= 2
	;;
	if v <= 0xff
		-> 8
	elif v <= 0xffff
		-> 16
	elif v <= 0xffffffff
		-> 32
	else
		-> 64
	;;
}

const kwident = {p
	match identstr(p)
	| "$": 	-> `Tidxlen
	| "_": 	-> `Tgap
	| "$noret": 	-> `Tnoret
	| "break": 	-> `Tbreak
	| "castto": 	-> `Tcast
	| "const": 	-> `Tconst
	| "continue": 	-> `Tcontinue
	| "elif": 	-> `Telif
	| "else": 	-> `Telse
	| "extern": 	-> `Textern
	| "false": 	-> `Tboollit false
	| "for": 	-> `Tfor
	| "generic": 	-> `Tgeneric
	| "goto": 	-> `Tgoto
	| "if": 	-> `Tif
	| "impl": 	-> `Timpl
	| "in": 	-> `Tin
	| "match": 	-> `Tmatch
	| "pkg": 	-> `Tpkg
	| "pkglocal": 	-> `Tpkglocal
	| "sizeof": 	-> `Tsizeof
	| "struct": 	-> `Tstruct
	| "trait": 	-> `Ttrait
	| "true": 	-> `Tboollit true
	| "type": 	-> `Ttype
	| "union": 	-> `Tunion
	| "use": 	-> `Tuse
	| "var": 	-> `Tvar
	| "void": 	-> `Tvoidlit
	| "while": 	-> `Twhile
	| ident:	-> `Tident std.sldup(ident)
	;;
}

const oper = {p
	var t, chr

	chr = takec(p)
	match chr
	| '{': t = `Tobrace
	| '}': t = `Tcbrace
	| '(': t = `Toparen
	| ')': t = `Tcparen
	| '[': t = `Tosqbrac
	| ']': t = `Tcsqbrac
	| ',': t = `Tcomma
	| '`': t = `Ttick
	| '#': t = `Tderef
	| '~': t = `Tbnot
	| ':':
		if matchc(p, ':')
			t = `Twith
		else
			t = `Tcolon;
		;;
	| ';':
		if matchc(p, ';')
			t = `Tendblk;
		else
			t = `Tendln;
		;;
	| '.':
		if npeekc(p, 1) == '.' && npeekc(p, 2) == '.'
			takec(p)
			takec(p)
			t = `Tellipsis;
		else
			t = `Tdot;
		;;
	| '+':
		if matchc(p, '=')
			t = `Taddeq;
		elif matchc(p, '+')
			t = `Tinc;
		else
			t = `Tplus;
		;;
	| '-':
		if matchc(p, '=')
			t = `Tsubeq;
		elif matchc(p, '-')
			t = `Tdec;
		elif matchc(p, '>')
			t = `Tret;
		else
			t = `Tminus;
		;;
	| '*':
		if matchc(p, '=')
			t = `Tmuleq;
		else
			t = `Tmul;
		;;
	| '/':
		if matchc(p, '=')
			t = `Tdiveq;
		else
			t = `Tdiv;
		;;
	| '%':
		if matchc(p, '=')
			t = `Tmodeq;
		else
			t = `Tmod;
		;;
	| '=':
		if matchc(p, '=')
			t = `Teq;
		else
			t = `Tasn;
		;;
	| '|':
		if matchc(p, '=')
			t = `Tboreq;
		elif matchc(p, '|')
			t = `Tlor;
		else
			t = `Tbor;
		;;
	| '&':
		if matchc(p, '=')
			t = `Tbandeq;
		elif matchc(p, '&')
			t = `Tland;
		else
			t = `Tband;
		;;
	| '^':
		if matchc(p, '=')
			t = `Tbxoreq;
		else
			t = `Tbxor;
		;;
	| '<':
		if matchc(p, '=')
			t = `Tle;
		elif matchc(p, '<')
			if matchc(p, '=')
				t = `Tbsleq;
			else
				t = `Tbsl;
			;;
		else
			t = `Tlt;
		;;
	| '>':
		if matchc(p, '=')
			t = `Tge;
		elif matchc(p, '>')
			if matchc(p, '=')
				t = `Tbsreq;
			else
				t = `Tbsr;
			;;
		else
			t = `Tgt;
		;;

	| '!':
		if matchc(p, '=')
			t = `Tne;
		else
			t = `Tlnot;
		;;
	| c:
		t = `Terror;
		err(p.loc, "junk character {}", c);
	;;
	-> t
}

const identstr = {p
	var i, str

	/* ASCII */
	if p.rest.len == 0 || std.isdigit(std.decode(p.rest))
		-> ""
	;;

	for i = 0; i < p.rest.len; i++
		if !isident(std.decode(p.rest[i:]))
			break
		;;
	;;
	str = p.rest[:i]
	p.rest = p.rest[i:]
	-> str
}

const isident = {c
	-> c & 0x80 == 0 && \
		(c >= 'a' && c <= 'z' || \
		 c >= 'A' && c <= 'Z' || \
		 c >= '0' && c <= '9' || \
		 c == '_' || c == '$')
}

const peekc = {p
	-> std.decode(p.rest)
}

const npeekc = {p, n
	var c, s

	s = p.rest
	for var i = 0; i < n; i++
		(c, s) = std.strstep(s)
	;;
	-> std.decode(s)
}

const takec = {p
	var c, s

	(c, s) = std.strstep(p.rest)
	p.rest = s
	-> c
}

const skipto = {p, chr
	var c, s

	s = p.rest
	while true
		(c, s) = std.strstep(s)
		if s.len == 0 || c == chr
			break
		;;
	;;
}

const matchc = {p, chr
	var c, s

	(c, s) = std.strstep(p.rest)
	if c == chr
		p.rest = s
		-> true
	else
		-> false
	;;
}
