use std

use "ast"
use "stab"
use "tok"
use "tokdefs"
use "type"
use "types"
use "node"
use "util"

pkg parse =
	const tsfile	: (p : parser# -> file#)
;;

const tsfile = {p
	var f
	var t : tok
	var vis : vis = `Visintern

	/* initialize the parser and file state */
	f = std.mk([
		.uses = [][:],
		.libs = [][:],
		.extlibs = [][:],
		.dcls = [][:],
		.extinit = [][:],
		.init = `std.None,
		.globls = mkstab(),
		.builtin = mkstab(),
		.ns = std.mkht(std.strhash, std.streq),
	])
	f.globls.super = `std.Some f.builtin

	/* parse */
	optendlns(p)
	while true
		match tokpeek(p)
		| (l, `Teof):	break
		| (l, `Tuse):	usestmt(p, f)
		| (l, `Tpkg):	pkgdef(p, f)
		| (l, `Ttrait):	traitdef(p, f)
		| (l, `Ttype):	tydef(p, f)
		| (l, `Tendln):	endlns(p)
		| (l, tok):	
			if !vardcl(p, f, true, vis)
				err(l, "invalid top level item near {}", tok)
			;;
		;;
	;;
	-> f
}

const usestmt = {p, f
	match toknext(p)
	| (l, `Tuse): /* ok */
	| (l, t):	err(l, "unexpected token in use {}\n", t)
	;;

	match toknext(p)
	| (l, `Tstrlit str):	std.slpush(&f.uses, `Ulocal str)
	| (l, `Tident id):	std.slpush(&f.uses, `Ulib id)
	| (l, t):	err(l, "unexpected {} after use\n", t)
	;;
}

const pkgdef = {p, f
	std.fatal("unimplemented pkg\n")
}

const traitdef = {p, f
	std.fatal("unimplemented trait\n")
}

const tydef = {p, f
	std.fatal("unimplemented type\n")
}

const vardcl = {p, f, isglobl, vis
	var dcl : dcl
	var hadattr

	/* attributes */
	dcl = [
		.id = f.dcls.len,
		.vis = vis,
		.init = `std.None,
		.tr = `std.None,
		.isglobl = isglobl,
	]

	hadattr = dclattrs(p, &dcl)
	/* attributes (const | var) */
	match tokpeek(p)
	| (l, `Tvar):	dcl.isconst = false
	| (l, `Tconst):	dcl.isconst = true
	| (l, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, badtok):
		if hadattr
			err(l, "unexpected {} in declaration, got {}\n", badtok)
		else
			-> false
		;;
	;;
	if !dcltag(p, &dcl)
		if hadattr
		else
			-> false
		;;
	;;
	dclname(p, &dcl)
	dcltype(p, &dcl)
	dclinit(p, &dcl)
	std.slpush(&f.dcls, std.mk(dcl))
	-> true
}


const dclname = {p, dcl : dcl#
	/* attributes (const | var) name */
	match name(p)
	| `std.Some n:
		if n.ns.len > 0 && !dcl.isextern
			std.fatal("only extern decls may provide namespaces\n")
		;;
		dcl.name = n
	| `std.None:	
		std.fatal("expected name in decl, got {}\n", tokpeekt(p))
	;;
}

const dcltype = {p, dcl
	match tokpeek(p)
	| (l, `Tcolon):
		toknext(p)
		match typ(p)
		| `std.Some t:	dcl.ty = t
		| `std.None:	err(l, "expected type after ':'\n")
		;;
	| (l, _):
		dcl.ty = mktyvar(l)
	;;
}

const dclinit = {p, dcl
	match tokpeek(p)
	| (l, `Tasn):
		toknext(p)
		match expr(p)
		| `std.Some e:	dcl.init = `std.Some e
		| `std.None:	err(l, "expected initializer after '='\n")
		;;
		-> true
	| tok:	
		dcl.init = `std.None
	;;

	-> false
}

const expr = {p
	match unionexpr(p)
	| `std.Some e:	-> `std.Some exprcore(p, e, 0)
	| `std.None:	-> `std.None
	;;
}

const exprcore = {p, lhs, minprec
	var peek, peekloc, assoc
	var prec, peekprec
	var op, oploc
	var rhs

	(peekloc, peek) = tokpeek(p)
	while true
		(prec, assoc) = exprprec(peek) 
		if prec < minprec
			break
		;;

		op = peek
		oploc = peekloc
		toknext(p)

		match unionexpr(p)
		| `std.Some e:	rhs = e
		| `std.None:	err(p.loc, "expected primary expression after {}, near {}", op, tokpeekt(p))
		;;

		(peekloc, peek) = tokpeek(p)
		while true
			(peekprec, assoc) = exprprec(peek)
			if (!assoc && peekprec <= prec) || (assoc && peekprec < prec)
				break
			;;
			rhs = binexprcore(p, rhs, peekprec)
			(peekloc, peek) = tokpeek(p)
		;;
		match op
		/* assignmets */
		| `Tasn:	lhs = mkexpr(oploc, `Oasn (lhs, rhs))
		| `Taddeq:	lhs = mkexpr(oploc, `Oaddeq (lhs, rhs))
		| `Tsubeq:	lhs = mkexpr(oploc, `Osubeq (lhs, rhs))
		| `Tmuleq:	lhs = mkexpr(oploc, `Omuleq (lhs, rhs))
		| `Tdiveq:	lhs = mkexpr(oploc, `Odiveq (lhs, rhs))
		| `Tmodeq:	lhs = mkexpr(oploc, `Omodeq (lhs, rhs))
		| `Tboreq:	lhs = mkexpr(oploc, `Oboreq (lhs, rhs))
		| `Tbandeq:	lhs = mkexpr(oploc, `Obandeq (lhs, rhs))
		| `Tbsleq:	lhs = mkexpr(oploc, `Obsleq (lhs, rhs))
		| `Tbsreq:	lhs = mkexpr(oploc, `Obsreq (lhs, rhs))
		/* logical ops */
		| `Tlor:	lhs = mkexpr(oploc, `Olor (lhs, rhs))
		| `Tland:	lhs = mkexpr(oploc, `Oland (lhs, rhs))
		/* multiplicative */
		| `Teq:	lhs = mkexpr(oploc, `Oeq (lhs, rhs))
		| `Tgt:	lhs = mkexpr(oploc, `Ogt (lhs, rhs))
		| `Tge:	lhs = mkexpr(oploc, `Oge (lhs, rhs))
		| `Tlt:	lhs = mkexpr(oploc, `Olt (lhs, rhs))
		| `Tle:	lhs = mkexpr(oploc, `Ole (lhs, rhs))
		| `Tne:	lhs = mkexpr(oploc, `One (lhs, rhs))
		| _:	std.die("broken parser")
		;;
	;;
	-> lhs
}

const exprprec = {tok
	match tok
	/* assignmets */
	| `Tasn:	-> (0, true)
	| `Taddeq:	-> (0, true)
	| `Tsubeq:	-> (0, true)
	| `Tmuleq:	-> (0, true)
	| `Tdiveq:	-> (0, true)
	| `Tmodeq:	-> (0, true)
	| `Tboreq:	-> (0, true)
	| `Tbandeq:	-> (0, true)
	| `Tbsleq:	-> (0, true)
	| `Tbsreq:	-> (0, true)
	/* logical ops */
	| `Tlor:	-> (1, false)
	| `Tland:	-> (2, false)
	/* multiplicative */
	| `Teq:	-> (3, false)
	| `Tgt:	-> (3, false)
	| `Tge:	-> (3, false)
	| `Tlt:	-> (3, false)
	| `Tle:	-> (3, false)
	| `Tne:	-> (3, false)
	/* all others */
	| _:	-> (-1, false)
	;;
}

const unionexpr = {p
	var tag, expr

	match tokpeek(p)
	| (l, `Ttick):
		toknext(p)
		match name(p)
		| `std.Some n:	tag = n
		| `std.None:	err(l, "expected union tag after '`'\n")
		;;

		expr = castexpr(p)
		-> `std.Some mkexpr(l, `Oucon (tag, expr))
	| _:
		-> castexpr(p)
	;;
}

const castexpr = {p
	var ty

	match binexpr(p)
	| `std.Some e:
		match tokpeek(p)
		| (l, `Tcast):
			toknextt(p)
			match toknext(p)
			| (pl, `Toparen):
			| (pl, badtok):	err(l, "expected '(' after 'castto', got {}\n", badtok)
			;;

			match typ(p)
			| `std.Some t:	ty = t
			| `std.None:	err(p.loc, "expected type in castto near {}\n", tokpeekt(p))
			;;

			match toknext(p)
			| (pl, `Tcparen):
			| (pl, badtok):	err(l, "expected '(' after 'castto', got {}\n", badtok)
			;;

			-> `std.Some mkexpr(l, `Ocast (e, ty))
		| _:	
			-> `std.Some e
		;;
	| `std.None:
		-> `std.None
	;;
}

const binexpr = {p
	match prefixexpr(p)
	| `std.Some e:	-> `std.Some binexprcore(p, e, 0)
	| `std.None:	-> `std.None
	;;
}

const binexprcore = {p, lhs, minprec
	var prec, peekprec
	var op, oploc
	var peek, peekloc
	var rhs

	(peekloc, peek) = tokpeek(p)
	while true
		prec = binprec(peek) 
		if prec < minprec
			break
		;;

		op = peek
		oploc = peekloc
		toknext(p)

		match prefixexpr(p)
		| `std.Some e:	rhs = e
		| `std.None:	err(p.loc, "expected primary expression after {}, near {}", op, tokpeekt(p))
		;;

		(peekloc, peek) = tokpeek(p)
		while true
			peekprec = binprec(peek)
			if peekprec <= prec
				break
			;;
			rhs = binexprcore(p, rhs, peekprec)
			(peekloc, peek) = tokpeek(p)
		;;
		match op
		/* binary or */
		| `Tbor:	lhs = mkexpr(oploc, `Obor (lhs, rhs))
		| `Tbxor:	lhs = mkexpr(oploc, `Obxor (lhs, rhs))
		/* binary and */
		| `Tband:	lhs = mkexpr(oploc, `Oband (lhs, rhs))
		/* additive */
		| `Tplus:	lhs = mkexpr(oploc, `Oadd (lhs, rhs))
		| `Tminus:	lhs = mkexpr(oploc, `Osub (lhs, rhs))
		/* multiplicative */
		| `Tmul:	lhs = mkexpr(oploc, `Omul (lhs, rhs))
		| `Tdiv:	lhs = mkexpr(oploc, `Odiv (lhs, rhs))
		| `Tmod:	lhs = mkexpr(oploc, `Omod (lhs, rhs))
		/* shift */
		| `Tbsl:	lhs = mkexpr(oploc, `Obsl (lhs, rhs))
		| `Tbsr:	lhs = mkexpr(oploc, `Obsr (lhs, rhs))
		/* all others */
		| _:	std.die("broken parser")
		;;
	;;
	-> lhs
}

const binprec = {tok
	match tok
	/* binary or */
	| `Tbor:	-> 0
	| `Tbxor:	-> 0
	/* binary and */
	| `Tband:	-> 1
	/* additive */
	| `Tplus:	-> 2
	| `Tminus:	-> 2
	/* multiplicative */
	| `Tmul:	-> 3
	| `Tdiv:	-> 3
	| `Tmod:	-> 3
	/* shift */
	| `Tbsl:	-> 4
	| `Tbsr:	-> 3
	/* all others */
	| _:	-> -1
	;;
}

const prefixexpr = {p
	match toknext(p)
	| (l, `Tinc):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opreinc e)
		| `std.None:	-> `std.None
		;;
	| (l, `Tdec):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opredec e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tband):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oaddr e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tlnot):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Olnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tbnot):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Obnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tminus):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oneg e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tplus):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some e
		|`std.None:	-> `std.None
		;;
	| _:	
		tokunget(p)
		-> postfixexpr(p)
	;;
}

const postfixexpr = {p
	var e

	match atomicexpr(p)
	| `std.Some r:	e = r
	| `std.None:	-> `std.None
	;;

	while true
		match toknext(p)
		| (l, `Tdot):	
			match toknext(p)
			| (ml, `Tident memb):	e = mkexpr(l, `Omemb (e, memb))
			| (ml, badtok):	err(ml, "expected member after '.', got {}\n", badtok)
			;;
		| (l, `Tinc):	e = mkexpr(l, `Opostinc e)
		| (l, `Tdec):	e = mkexpr(l, `Opostdec e)
		| (l, `Tderef):	e = mkexpr(l, `Oderef e)
		| (l, `Tosqbrac):	e = idxexpr(p, e)
		| (l, `Toparen):	e = callexpr(p, e)
		| tok:	
			tokunget(p)
			break
		;;
	;;
	-> `std.Some e
}

const idxexpr = {p : parser#, base
	var hadsl
	var lo, hi
	var loc

	loc = p.loc

	/* open [ is consumed by caller */

	match expr(p)
	| `std.Some e:	lo = `std.Some e
	| `std.None:	lo = `std.None
	;;

	hadsl = false
	match tokpeek(p)
	| (l, `Tcolon):
		toknext(p)
		hadsl = true
		match expr(p)
		| `std.Some e:	hi = `std.Some e
		| `std.None:	hi = `std.None
		;;
	| (l, tok):
		match lo
		| `std.Some _:	/* ok */
		| `std.None:	err(l, "expected index in expr, got {}\n", tok)
		;;

	;;

	match toknext(p)
	| (_, `Tcsqbrac):	/* ok */
	| (l, badtok):	err(l, "expected ']' after indexer, got {}\n", badtok)
	;;

	if hadsl
		-> mkexpr(loc, `Oslice (base, lo, hi))
	else
		match lo
		| `std.Some e:	-> mkexpr(loc, `Oidx (base, e))
		| `std.None:	std.die("should be unreachable\n")
		;;
	;;

}

const callexpr = {p, e
	var args
	/* open ) is consumed by caller */

	args = callargs(p)

	match toknext(p)
	| (_, `Tcparen):	/* ok */
	| (l, badtok):	err(l, "expected ')' after call, got {}\n", badtok)
	;;
	
	-> mkexpr(p.loc, `Ocall (e, args))

}

const callargs = {p
	var args

	args = [][:]
	match expr(p)
	| `std.None:	-> args
	| `std.Some e:	std.slpush(&args, e)
	;;

	while true
		match toknext(p)
		| (l, `Tcomma):
			match expr(p)
			| `std.Some e:	std.slpush(&args, e)
			| `std.None:	err(l, "expected expression after ',' in function args\n")
			;;
		| _:
			tokunget(p)
			break
		;;
	;;
	-> args
}

const atomicexpr = {p
	var e

	match toknext(p)
	| (l, `Tgap):		e = `std.Some mkexpr(l, `Ogap)
	| (l, `Tident n):	e = `std.Some mkexpr(l, `Ovar [.ns="", .name=n])
	| (l, `Tintlit i):	e = `std.Some mkexpr(l, `Olit `Lint i)
	| (l, `Tstrlit s):	e = `std.Some mkexpr(l, `Olit `Lstr s)
	| (l, `Tfltlit f):	e = `std.Some mkexpr(l, `Olit `Lflt f)
	| (l, `Tchrlit c):	e = `std.Some mkexpr(l, `Olit `Lchr c)
	| (l, `Tboollit b):	e = `std.Some mkexpr(l, `Olit `Lbool b)
	| (l, `Tvoidlit):	e = `std.Some mkexpr(l, `Olit `Lvoid)
	| (l, `Tsizeof):	e = sizeofexpr(p, l)
	| (l, `Tobrace):	e = funcexpr(p, l)
	| _:
		tokunget(p)
		e = `std.None
	;;

	-> e
}

const sizeofexpr = {p, loc
	var e

	match toknext(p)
	| (_, `Toparen):	/* ok */
	| (l, badtok):	err(l, "expected '(' after sizeof, got {}\n", badtok)
	;;

	match typ(p)
	| `std.Some ty:	e = mkexpr(loc, `Osize ty)
	| `std.None:	err(p.loc, "expected type in sizeof, got {}\n", tokpeekt(p))
	;;

	match toknext(p)
	| (_, `Toparen):	/* ok */
	| (l, badtok):	err(l, "expected '(' after sizeof, got {}\n", badtok)
	;;

	-> `std.Some e
}

const funcexpr = {p, loc
	-> `std.None
}

const dclattrs = {p, dcl
	var hadattr

	hadattr = false
	while true
		match tokpeek(p)
		| (_, `Tpkglocal):	dcl.ispkglocal = true
		| (_, `Textern):	dcl.isextern = true
		| (_, `Tnoret):		dcl.isnoret = true
		| _:	break
		;;
		toknext(p)
		hadattr = true
	;;
	-> hadattr
}

const dcltag = {p, dcl
	/* attributes (const | var) */
	match tokpeek(p)
	| (_, `Tvar):	dcl.isconst = false
	| (_, `Tconst):	dcl.isconst = true
	| (_, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, badtok):
		-> false
	;;
	toknext(p)
	-> true
}

const name = {p -> std.option(name)
	var ns, n

	match tokpeek(p)
	| (l, `Tident id):	n = id
	| (l, tok):	-> `std.None
	;;
	toknext(p)

	match tokpeek(p)
	| (l, `Tdot):	ns = n
	| (l, _):	-> `std.Some [.ns = "", .name = n]
	;;
	toknext(p)

	match tokpeek(p)
	| (l, `Tident id):	n = id
	| (l, tok):	err(l, "expected after '.', got {}\n", tok)
	;;
	toknext(p)

	-> `std.Some [.ns=ns, .name=n]
}

const typ = {p
	var ty

	match toknext(p)
	| (l, `Tstruct):	ty = tystruct(p)
	| (l, `Tunion):		ty = tyunion(p)
	| (l, `Tellipsis):	ty = mkty(l, `Tyvalist)
	| (l, `Ttyparam n):	ty = mkty(l, `Typaram n)
	| (l, `Tident id):
		tokunget(p)
		ty = tyname(p)
	| (l, badtok):	
		tokunget(p)
		-> `std.None
	;;

	-> `std.Some tysuffixed(p, ty)
}

const tystruct = {p
	/* already have struct token */
	err(p.loc, "struct not yet supported\n")
	-> std.alloc()
}

const tyunion = {p
	/* already have union token */
	err(p.loc, "struct not yet supported\n")
	-> std.alloc()
}

const tyname = {p
	var nam, params

	match name(p)
	| `std.Some n:	nam = n
	| `std.None:	std.die("we came hear after peeking an ident\n")
	;;

	params = [][:]
	match tokpeek(p)
	| (l, `Toparen):	err(l, "param lists aren't yet supported\n")
	| (l, _):
	;;

	-> mkty(p.loc, `Tyunres (nam, params))
}

const tysuffixed = {p, base
	while true
		match toknext(p)
		| (l, `Tderef):	base = mkty(l, `Typtr base)
		| (l, `Tosqbrac):
			match tokpeekt(p)
			| `Tcolon:
				toknext(p)
				base = mkty(l, `Tyslice base)
				expectcsqbrac(p, "in slice type")
			| _:
				match expr(p)
				| `std.Some e:	base = mkty(l, `Tyarray (base, e))
				| `std.None:	err(p.loc, "expected expression in array size\n")
				;;
				expectcsqbrac(p, "in array type")
			;;
		| _:
			tokunget(p)
			break
		;;
	;;
	-> base
}

const expectcsqbrac = {p, msg
	match toknext(p)
	| (l, `Tcsqbrac):	/* nothing */
	| (l, tok):	err(l, "expected ']' in {}, got {}\n", msg, tok)
	;;
}

const optendlns = {p
	while true
		match tokpeek(p)
		| (l, `Tendln): toknext(p)
		| _:    break
		;;
	;;
}

const endlns = {p
	match tokpeek(p)
	| (l, `Tendln): optendlns(p)
	| (l, tok):	err(l, "expected \\n, got {}\n", tok)
	;;
	-> true
}
