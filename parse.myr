use std

use "ast"
use "stab"
use "tok"
use "tokdefs"
use "types"
use "node"
use "util"

pkg parse =
	const tsfile	: (p : parser# -> file#)
;;

const tsfile = {p
	var f
	var t : tok
	var vis : vis = `Visintern

	/* initialize the parser and file state */
	f = std.mk([
		.uses = [][:],
		.libs = [][:],
		.extlibs = [][:],
		.dcls = [][:],
		.extinit = [][:],
		.init = `std.None,
		.globls = mkstab(`std.None),
		.builtin = mkstab(`std.None),
		.ns = std.mkht(std.strhash, std.streq),
	])
	f.globls.super = `std.Some f.builtin
	pushstab(p, f.globls)

	/* parse */
	p.file = f
	optendlns(p)
	while true
		match tokpeek(p)
		| (l, `Teof):	break
		| (l, `Tuse):	usestmt(p)
		| (l, `Tpkg):	pkgdef(p)
		| (l, `Ttrait):	traitdef(p)
		| (l, `Ttype):	tydefn(p)
		| (l, `Tendln):	endlns(p)
		| (l, tok):	
			if !vardcl(p, true, vis)
				err(l, "invalid top level item near {}", tok)
			;;
		;;
	;;
	-> f
}

const usestmt = {p
	match toknext(p)
	| (l, `Tuse): /* ok */
	| (l, t):	err(l, "unexpected token in use {}\n", t)
	;;

	match toknext(p)
	| (l, `Tstrlit str):	std.slpush(&p.file.uses, `Ulocal str)
	| (l, `Tident id):	std.slpush(&p.file.uses, `Ulib id)
	| (l, t):	err(l, "unexpected {} after use\n", t)
	;;
}

const pkgdef = {p
	std.fatal("unimplemented pkg\n")
}

const traitdef = {p
	std.fatal("unimplemented trait\n")
}

const tydefn = {p
	var name, loc, params : tydef#[:], ty

	match toknext(p)
	| (l, `Ttype):	/* consume */
	| (l, tokbad):	err(l, "expected 'type', got {}\n", tokbad)
	;;

	match toknext(p)
	| (l, `Tident id):	(name, loc) = (id, l)
	| (l, tokbad):	err(l, "expected type name, got {}\n", tokbad)
	;;

	params = [][:]
	match tokpeek(p)
	| (l, `Toparen):	params = typarams(p)
	| _:	/* nothing */
	;;

	match toknext(p)
	| (l, `Tasn):
		match typ(p)
		| `std.Some t:	ty = `std.Some t
		| `std.None:	err(l, "expected type definition after 'type {} ='\n", name)
		;;
	| (l, `Tendln):
		ty = `std.None
	| (l, tokbad):
		err(l, "expected = after type, got {}\n", tokbad)
	;;

	match ty
	| `std.Some t:	puttype(p.file.globls, [.ns = p.curns, .name=name], t)
	| `std.None:	puttypefwd(p.file.globls, [.ns=p.curns, .name=name], loc)
	;;
}

const typarams = {p
	std.fatal("typarams not implemented\n")
	-> std.slalloc(0)
}

const vardcl = {p, isglobl, vis
	var dcl : dcl#
	var hadattr

	/* attributes */
	dcl = std.mk([
		.id = p.file.dcls.len,
		.vis = vis,
		.init = `std.None,
		.tr = `std.None,
		.isglobl = isglobl,
	])

	hadattr = dclattrs(p, dcl)
	/* attributes (const | var) */
	match tokpeek(p)
	| (l, `Tvar):	dcl.isconst = false
	| (l, `Tconst):	dcl.isconst = true
	| (l, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, tokbad):
		if hadattr
			err(l, "unexpected {} in declaration, got {}\n", tokbad)
		else
			-> false
		;;
	;;
	if !dcltag(p, dcl)
		if hadattr
			err(p.loc, "expected declaration after attr names\n")
		else
			-> false
		;;
	;;
	dclname(p, dcl)
	dcltype(p, dcl)
	dclinit(p, dcl)
	putdcl(p.file.globls, dcl.name, dcl)
	std.slpush(&p.file.dcls, dcl)
	-> true
}

const dclattrs = {p, dcl
	var hadattr

	hadattr = false
	while true
		match tokpeek(p)
		| (_, `Tpkglocal):	dcl.ispkglocal = true
		| (_, `Textern):	dcl.isextern = true
		| (_, `Tnoret):		dcl.isnoret = true
		| _:	break
		;;
		toknext(p)
		hadattr = true
	;;
	-> hadattr
}

const dcltag = {p, dcl
	/* attributes (const | var) */
	match tokpeek(p)
	| (_, `Tvar):	dcl.isconst = false
	| (_, `Tconst):	dcl.isconst = true
	| (_, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, tokbad):
		-> false
	;;
	toknext(p)
	-> true
}

const dclname = {p, dcl : dcl#
	/* attributes (const | var) name */
	match name(p)
	| `std.Some n:
		if n.ns.len > 0 && !dcl.isextern
			std.fatal("only extern decls may provide namespaces\n")
		;;
		dcl.name = n
	| `std.None:	
		std.fatal("expected name in decl, got {}\n", tokpeekt(p))
	;;
}

const dcltype = {p, dcl
	match tokpeek(p)
	| (l, `Tcolon):
		toknext(p)
		match typ(p)
		| `std.Some t:	dcl.ty = t
		| `std.None:	err(l, "expected type after ':'\n")
		;;
	| (l, _):
		dcl.ty = mktyvar(l)
	;;
}

const dclinit = {p, dcl
	match tokpeek(p)
	| (l, `Tasn):
		toknext(p)
		match expr(p)
		| `std.Some e:	dcl.init = `std.Some e
		| `std.None:	err(l, "expected initializer after '='\n")
		;;
		-> true
	| tok:	
		dcl.init = `std.None
	;;

	-> false
}

const expr = {p
	match unionexpr(p)
	| `std.Some e:	-> `std.Some exprcore(p, e, 0)
	| `std.None:	-> `std.None
	;;
}

const exprcore = {p, lhs, minprec
	var peek, peekloc, assoc
	var prec, peekprec
	var op, oploc
	var rhs

	(peekloc, peek) = tokpeek(p)
	while true
		(prec, assoc) = exprprec(peek) 
		if prec < minprec
			break
		;;

		op = peek
		oploc = peekloc
		toknext(p)

		match unionexpr(p)
		| `std.Some e:	rhs = e
		| `std.None:	err(p.loc, "expected primary expression after {}, near {}", op, tokpeekt(p))
		;;

		(peekloc, peek) = tokpeek(p)
		while true
			(peekprec, assoc) = exprprec(peek)
			if (!assoc && peekprec <= prec) || (assoc && peekprec < prec)
				break
			;;
			rhs = binexprcore(p, rhs, peekprec)
			(peekloc, peek) = tokpeek(p)
		;;
		match op
		/* assignmets */
		| `Tasn:	lhs = mkexpr(oploc, `Oasn (lhs, rhs))
		| `Taddeq:	lhs = mkexpr(oploc, `Oaddeq (lhs, rhs))
		| `Tsubeq:	lhs = mkexpr(oploc, `Osubeq (lhs, rhs))
		| `Tmuleq:	lhs = mkexpr(oploc, `Omuleq (lhs, rhs))
		| `Tdiveq:	lhs = mkexpr(oploc, `Odiveq (lhs, rhs))
		| `Tmodeq:	lhs = mkexpr(oploc, `Omodeq (lhs, rhs))
		| `Tboreq:	lhs = mkexpr(oploc, `Oboreq (lhs, rhs))
		| `Tbandeq:	lhs = mkexpr(oploc, `Obandeq (lhs, rhs))
		| `Tbsleq:	lhs = mkexpr(oploc, `Obsleq (lhs, rhs))
		| `Tbsreq:	lhs = mkexpr(oploc, `Obsreq (lhs, rhs))
		/* logical ops */
		| `Tlor:	lhs = mkexpr(oploc, `Olor (lhs, rhs))
		| `Tland:	lhs = mkexpr(oploc, `Oland (lhs, rhs))
		/* multiplicative */
		| `Teq:	lhs = mkexpr(oploc, `Oeq (lhs, rhs))
		| `Tgt:	lhs = mkexpr(oploc, `Ogt (lhs, rhs))
		| `Tge:	lhs = mkexpr(oploc, `Oge (lhs, rhs))
		| `Tlt:	lhs = mkexpr(oploc, `Olt (lhs, rhs))
		| `Tle:	lhs = mkexpr(oploc, `Ole (lhs, rhs))
		| `Tne:	lhs = mkexpr(oploc, `One (lhs, rhs))
		| _:	std.die("broken parser")
		;;
	;;
	-> lhs
}

const exprprec = {tok
	match tok
	/* assignmets */
	| `Tasn:	-> (0, true)
	| `Taddeq:	-> (0, true)
	| `Tsubeq:	-> (0, true)
	| `Tmuleq:	-> (0, true)
	| `Tdiveq:	-> (0, true)
	| `Tmodeq:	-> (0, true)
	| `Tboreq:	-> (0, true)
	| `Tbandeq:	-> (0, true)
	| `Tbsleq:	-> (0, true)
	| `Tbsreq:	-> (0, true)
	/* logical ops */
	| `Tlor:	-> (1, false)
	| `Tland:	-> (2, false)
	/* multiplicative */
	| `Teq:	-> (3, false)
	| `Tgt:	-> (3, false)
	| `Tge:	-> (3, false)
	| `Tlt:	-> (3, false)
	| `Tle:	-> (3, false)
	| `Tne:	-> (3, false)
	/* all others */
	| _:	-> (-1, false)
	;;
}

const unionexpr = {p
	var tag, expr

	match tokpeek(p)
	| (l, `Ttick):
		toknext(p)
		match name(p)
		| `std.Some n:	tag = n
		| `std.None:	err(l, "expected union tag after '`'\n")
		;;

		expr = castexpr(p)
		-> `std.Some mkexpr(l, `Oucon (tag, expr))
	| _:
		-> castexpr(p)
	;;
}

const castexpr = {p
	var ty

	match binexpr(p)
	| `std.Some e:
		match tokpeek(p)
		| (l, `Tcast):
			toknextt(p)
			match toknext(p)
			| (pl, `Toparen):
			| (pl, tokbad):	err(l, "expected '(' after 'castto', got {}\n", tokbad)
			;;

			match typ(p)
			| `std.Some t:	ty = t
			| `std.None:	err(p.loc, "expected type in castto near {}\n", tokpeekt(p))
			;;

			match toknext(p)
			| (pl, `Tcparen):
			| (pl, tokbad):	err(l, "expected '(' after 'castto', got {}\n", tokbad)
			;;

			-> `std.Some mkexpr(l, `Ocast (e, ty))
		| _:	
			-> `std.Some e
		;;
	| `std.None:
		-> `std.None
	;;
}

const binexpr = {p
	match prefixexpr(p)
	| `std.Some e:	-> `std.Some binexprcore(p, e, 0)
	| `std.None:	-> `std.None
	;;
}

const binexprcore = {p, lhs, minprec
	var prec, peekprec
	var op, oploc
	var peek, peekloc
	var rhs

	(peekloc, peek) = tokpeek(p)
	while true
		prec = binprec(peek) 
		if prec < minprec
			break
		;;

		op = peek
		oploc = peekloc
		toknext(p)

		match prefixexpr(p)
		| `std.Some e:	rhs = e
		| `std.None:	err(p.loc, "expected primary expression after {}, near {}", op, tokpeekt(p))
		;;

		(peekloc, peek) = tokpeek(p)
		while true
			peekprec = binprec(peek)
			if peekprec <= prec
				break
			;;
			rhs = binexprcore(p, rhs, peekprec)
			(peekloc, peek) = tokpeek(p)
		;;
		match op
		/* binary or */
		| `Tbor:	lhs = mkexpr(oploc, `Obor (lhs, rhs))
		| `Tbxor:	lhs = mkexpr(oploc, `Obxor (lhs, rhs))
		/* binary and */
		| `Tband:	lhs = mkexpr(oploc, `Oband (lhs, rhs))
		/* additive */
		| `Tplus:	lhs = mkexpr(oploc, `Oadd (lhs, rhs))
		| `Tminus:	lhs = mkexpr(oploc, `Osub (lhs, rhs))
		/* multiplicative */
		| `Tmul:	lhs = mkexpr(oploc, `Omul (lhs, rhs))
		| `Tdiv:	lhs = mkexpr(oploc, `Odiv (lhs, rhs))
		| `Tmod:	lhs = mkexpr(oploc, `Omod (lhs, rhs))
		/* shift */
		| `Tbsl:	lhs = mkexpr(oploc, `Obsl (lhs, rhs))
		| `Tbsr:	lhs = mkexpr(oploc, `Obsr (lhs, rhs))
		/* all others */
		| _:	std.die("broken parser")
		;;
	;;
	-> lhs
}

const binprec = {tok
	match tok
	/* binary or */
	| `Tbor:	-> 0
	| `Tbxor:	-> 0
	/* binary and */
	| `Tband:	-> 1
	/* additive */
	| `Tplus:	-> 2
	| `Tminus:	-> 2
	/* multiplicative */
	| `Tmul:	-> 3
	| `Tdiv:	-> 3
	| `Tmod:	-> 3
	/* shift */
	| `Tbsl:	-> 4
	| `Tbsr:	-> 3
	/* all others */
	| _:	-> -1
	;;
}

const prefixexpr = {p
	match toknext(p)
	| (l, `Tinc):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opreinc e)
		| `std.None:	-> `std.None
		;;
	| (l, `Tdec):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opredec e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tband):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oaddr e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tlnot):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Olnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tbnot):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Obnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tminus):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oneg e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tplus):
		match prefixexpr(p)
		| `std.Some e:	-> `std.Some e
		|`std.None:	-> `std.None
		;;
	| _:	
		tokunget(p)
		-> postfixexpr(p)
	;;
}

const postfixexpr = {p
	var e

	match atomicexpr(p)
	| `std.Some r:	e = r
	| `std.None:	-> `std.None
	;;

	while true
		match toknext(p)
		| (l, `Tdot):	
			match toknext(p)
			| (ml, `Tident memb):	e = mkexpr(l, `Omemb (e, memb))
			| (ml, tokbad):	err(ml, "expected member after '.', got {}\n", tokbad)
			;;
		| (l, `Tinc):	e = mkexpr(l, `Opostinc e)
		| (l, `Tdec):	e = mkexpr(l, `Opostdec e)
		| (l, `Tderef):	e = mkexpr(l, `Oderef e)
		| (l, `Tosqbrac):	e = idxexpr(p, e)
		| (l, `Toparen):	e = callexpr(p, e)
		| tok:	
			tokunget(p)
			break
		;;
	;;
	-> `std.Some e
}

const idxexpr = {p : parser#, base
	var hadsl
	var lo, hi
	var loc

	loc = p.loc

	/* open [ is consumed by caller */

	match expr(p)
	| `std.Some e:	lo = `std.Some e
	| `std.None:	lo = `std.None
	;;

	hadsl = false
	match tokpeek(p)
	| (l, `Tcolon):
		toknext(p)
		hadsl = true
		match expr(p)
		| `std.Some e:	hi = `std.Some e
		| `std.None:	hi = `std.None
		;;
	| (l, tok):
		match lo
		| `std.Some _:	/* ok */
		| `std.None:	err(l, "expected index in expr, got {}\n", tok)
		;;

	;;

	match toknext(p)
	| (_, `Tcsqbrac):	/* ok */
	| (l, tokbad):	err(l, "expected ']' after indexer, got {}\n", tokbad)
	;;

	if hadsl
		-> mkexpr(loc, `Oslice (base, lo, hi))
	else
		match lo
		| `std.Some e:	-> mkexpr(loc, `Oidx (base, e))
		| `std.None:	std.die("should be unreachable\n")
		;;
	;;

}

const callexpr = {p, e
	var args
	/* open ) is consumed by caller */

	args = callargs(p)

	match toknext(p)
	| (_, `Tcparen):	/* ok */
	| (l, tokbad):	err(l, "expected ')' after call, got {}\n", tokbad)
	;;
	
	-> mkexpr(p.loc, `Ocall (e, args))

}

const callargs = {p
	var args

	args = [][:]
	match expr(p)
	| `std.None:	-> args
	| `std.Some e:	std.slpush(&args, e)
	;;

	while true
		match toknext(p)
		| (l, `Tcomma):
			match expr(p)
			| `std.Some e:	std.slpush(&args, e)
			| `std.None:	err(l, "expected expression after ',' in function args\n")
			;;
		| _:
			tokunget(p)
			break
		;;
	;;
	-> args
}

const atomicexpr = {p
	var e

	match toknext(p)
	| (l, `Tgap):		e = `std.Some mkexpr(l, `Ogap)
	| (l, `Tident n):	e = `std.Some mkexpr(l, `Ovar [.ns="", .name=n])
	| (l, `Tintlit i):	e = `std.Some mkexpr(l, `Olit `Lint i)
	| (l, `Tstrlit s):	e = `std.Some mkexpr(l, `Olit `Lstr s)
	| (l, `Tfltlit f):	e = `std.Some mkexpr(l, `Olit `Lflt f)
	| (l, `Tchrlit c):	e = `std.Some mkexpr(l, `Olit `Lchr c)
	| (l, `Tboollit b):	e = `std.Some mkexpr(l, `Olit `Lbool b)
	| (l, `Tvoidlit):	e = `std.Some mkexpr(l, `Olit `Lvoid)
	| (l, `Tobrace):	e = `std.Some funcexpr(p, l)
	| (l, `Tsizeof):	e = `std.Some sizeofexpr(p, l)
	| _:
		tokunget(p)
		e = `std.None
	;;

	-> e
}

const sizeofexpr = {p, loc
	var ty

	match toknext(p)
	| (_, `Toparen):	/* ok */
	| (l, tokbad):	err(l, "expected '(' after sizeof, got {}\n", tokbad)
	;;

	match typ(p)
	| `std.Some t:	ty = t
	| `std.None:	err(p.loc, "expected type in sizeof, got {}\n", tokpeekt(p))
	;;

	match toknext(p)
	| (_, `Toparen):	/* ok */
	| (l, tokbad):	err(l, "expected '(' after sizeof, got {}\n", tokbad)
	;;

	-> mkexpr(loc, `Osize ty)
}

const funcexpr = {p, loc
	/* opening { already matched */
	var args, blk, st, ty
	var fn

	args = [][:]
	st = mkstab(`std.Some p.curstab)
	pushstab(p, st)
	match toknext(p)
	| (l, `Tident id):	err(l, "don't yet support func args\n")
	| (l, `Tendln):	ty = mkty(loc, `Tyfunc std.sldup([mktyvar(loc)][:]))	/* (-> $t) */
	| (l, tokbad):	err(l, "expected function arguments near {}\n", tokbad)
	;;

	blk = blockbody(p, st)

	optendlns(p)
	match toknext(p)
	| (l, `Tcbrace):	/* we're ok */
	| (l, tokbad):	err(l, "expected '}}' at end of function, got {}\n", tokbad)
	;;

	fn = mkfunc(loc, st, ty, args, blk)
	-> mkexpr(loc, `Olit `Lfunc fn)
}

const ifstmt = {p
	-> `std.None
}

const forstmt = {p
	-> `std.None
}

const whilestmt = {p
	-> `std.None
}

const matchstmt = {p
	-> `std.None
}

const dclstmt = {p
	-> `std.None
}

const typestmt = {p
	-> `std.None
}

const traitstmt = {p
	-> `std.None
}

const implstmt = {p
	-> `std.None
}

const blockbody = {p, st
	var stmts

	stmts = [][:]
	while true
		match stmt(p)
		| `std.Some s:	std.slpush(&stmts, s)
		| `std.None:	break
		;;
	;;
	-> mkblk(p.loc, st, stmts)
}

const stmt = {p
	var loc

	loc = p.loc
	match expr(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Nexpr e)
	| `std.None:	/* nothing */
	;;
	match forstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Nloop e)
	| `std.None:	/* nothing */
	;;
	match whilestmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Niter e)
	| `std.None:	/* nothing */
	;;
	match ifstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Nif e)
	| `std.None:	/* nothing */
	;;
	match matchstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Nmatch e)
	| `std.None:	/* nothing */
	;;
	match dclstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Ndcl e)
	| `std.None:	/* nothing */
	;;
	match traitstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Ntrait e)
	| `std.None:	/* nothing */
	;;
	match implstmt(p)
	| `std.Some e:	-> `std.Some mkstmt(loc, `Nimpl e)
	| `std.None:	/* nothing */
	;;
	match typestmt(p)
	| `std.Some (n, t):	puttype(p.curstab, t, n)
	| `std.None:	/* nothing */
	;;

	-> `std.None
}

const name = {p -> std.option(name)
	var ns, n

	match tokpeek(p)
	| (l, `Tident id):	n = id
	| (l, tok):	-> `std.None
	;;
	toknext(p)

	match tokpeek(p)
	| (l, `Tdot):	ns = n
	| (l, _):	-> `std.Some [.ns = "", .name = n]
	;;
	toknext(p)

	match tokpeek(p)
	| (l, `Tident id):	n = id
	| (l, tok):	err(l, "expected after '.', got {}\n", tok)
	;;
	toknext(p)

	-> `std.Some [.ns=ns, .name=n]
}

const typ = {p
	var ty

	match toknext(p)
	| (l, `Tstruct):	ty = tystruct(p, l)
	| (l, `Tunion):		ty = tyunion(p, l)
	| (l, `Toparen):	ty = typaren(p, l)
	| (l, `Tellipsis):	ty = mkty(l, `Tyvalist)
	| (l, `Ttyparam n):	ty = mkty(l, `Typaram n)
	| (l, `Tvoidlit):	ty = mkty(l, `Tyvoid)
	| (l, `Tident id):
		tokunget(p)
		ty = tyname(p)
	| (l, tokbad):	
		tokunget(p)
		-> `std.None
	;;

	-> `std.Some tysuffixed(p, ty)
}

const tystruct = {p, loc
	var dcls

	/* 'struct' already consumed */
	dcls = [][:]
	while true
		endlns(p)
		match dclcore(p)
		| `std.Some d:	std.slpush(&dcls, d)
		| `std.None:	break
		;;
	;;
	std.put("..erm\n")

	// optendlns(p)
	match toknext(p)
	| (l, `Tendblk):	/* we're ok */
	| (l, tokbad):	err(l, "expected ';;' after struct decls, got {}\n", tokbad)
	;;
	-> mkty(loc, `Tystruct dcls)
}

const dclcore = {p
	var dcl
	var nam

	match toknext(p)
	| (l, `Tident n):
		nam = n
	| (l, _):
		tokunget(p)
		-> `std.None
	;;

	/* attributes */
	dcl = std.mk([
		.id = p.file.dcls.len,
		.vis = `Visintern,
		.init = `std.None,
		.tr = `std.None,
		.isglobl = false,
		.name = [.ns="", .name=nam]
	])
	dcltype(p, dcl)
	-> `std.Some dcl
}

const typaren = {p, loc
	match tokpeek(p)
	| (_, `Tident n):
		match name(p)
		| `std.None:	std.die("impossible: failed name after ident\n")
		| `std.Some nam:
			match tokpeek(p)
			| (l, `Tcolon):	-> functype(p, loc, `std.Some nam)
			| (l, `Tret):	-> functype(p, loc, `std.Some nam)
			| (l, _):	-> tupletype(p, loc, `std.Some nam)
			;;
		;;
	| (l, `Tret):
		-> functype(p, l, `std.None)
	| (l, tokbad):
		err(l, "expected name or '->' after '(' in type\n")
	;;
}

const functype = {p, loc, firstname
	var nam, args

	args = [][:]
	match firstname
	| `std.None:
		/* no names possible */
		match toknext(p)
		| (l, `Tret):	goto parseret
		| (l, tokbad):	err(l, "expected -> in function type, got {}\n", tokbad)
		;;
	| `std.Some n:
		nam = n
		goto parseargs
	;;
	while true
		match name(p)
		| `std.Some n:	nam = n
		| `std.None:	break
		;;
:parseargs
		match toknext(p)
		| (l, `Tret):	break
		| (l, `Tcolon):
			match typ(p)
			| `std.Some ty:	std.slpush(&args, ty)
			| `std.None:	err(l, "expected type after ':' in arg declaration\n")
			;;
		| (l, tokbad):
			err(l, "expected ':', '->' or ',' after arg name, got {}\n", tokbad)
		;;

		match toknext(p)
		| (l, `Tcomma):	/* nothing */
		| (l, `Tret):	break
		| (l, tokbad):	err(l, "expected ',' in function arg list, got {}\n", tokbad)
		;;
	;;

:parseret
	match typ(p)
	| `std.Some ty:	std.slput(&args, 0, ty)
	| `std.None:	err(p.loc, "expected return type after '->', got {}\n", tokpeek(p))
	;;

	match toknext(p)
	| (l, `Tcparen):	/* everything is ok */
	| (l, tokbad):	err(l, "expected ')' after function type, got '{}'\n", tokbad)
	;;

	-> mkty(loc, `Tyfunc args)
}

const tupletype = {p, loc, firstname
	var args

	args = [][:]
	match firstname
	| `std.None:	/* everything is ok */
	| `std.Some n:
		std.slpush(&args, typaramname(p, n))
		match toknext(p)
		| (l, `Tcomma):	/* nothing */
		| (l, `Tcparen):	/* nothing */
		| (l, tokbad):	err(l, "expected ',' in tuple type list, got {}\n", tokbad)
		;;
	;;

	while true
		std.put("tok: {}\n", tokpeekt(p))
		match typ(p)
		| `std.Some ty:	std.slpush(&args, ty)
		| `std.None:	break
		;;
		match toknext(p)
		| (l, `Tcomma):	/* nothing */
		| (l, `Tcparen):	break
		| (l, tokbad):	err(l, "expected ',' in tuple type list, got {}\n", tokbad)
		;;
	;;

	-> mkty(loc, `Tytuple args)
}

const tyunion = {p, loc
	var u, elts, loc
	var tag, tagloc, ty

	loc = p.loc
	elts = [][:]
	while true
		match tokpeek(p)
		| (l, `Ttick):	tagloc = l
		| _:	break
		;;

		match toknext(p)
		| (l, `Tident n):	tag = n
		| (l, tokbad):	err(l, "expected tag name after '`', got {}\n", tokbad)
		;;

		match tokpeek(p)
		| (l, `Tendln):	ty = `std.None
		| (l, _):
			match typ(p)
			| `std.Some t:	ty = `std.Some t
			| `std.None:	err(l, "expected type or endln after union tag\n")
			;;
		;;
		std.slpush(&elts, std.mk([
			.loc = tagloc,
			.tag = [.ns="", .name=tag],
			.ety = ty,
		]))

	;;

	u = mkty(loc, `Tyunion elts)
	for e in elts
		e.uty = u
	;;
	-> u
}

const tyname = {p
	match name(p)
	| `std.Some n:	-> typaramname(p, n)
	| `std.None:	std.die("we came hear after peeking an ident\n")
	;;
}

const typaramname = {p, nam
	var params

	params = [][:]
	match tokpeek(p)
	| (l, `Toparen):	err(l, "param lists aren't yet supported\n")
	| (l, _):
	;;

	-> mkty(p.loc, `Tyunres (nam, params))
}

const tysuffixed = {p, base
	while true
		match toknext(p)
		| (l, `Tderef):	base = mkty(l, `Typtr base)
		| (l, `Tosqbrac):
			match tokpeekt(p)
			| `Tcolon:
				toknext(p)
				base = mkty(l, `Tyslice base)
				expectcsqbrac(p, "in slice type")
			| _:
				match expr(p)
				| `std.Some e:	base = mkty(l, `Tyarray (base, e))
				| `std.None:	err(p.loc, "expected expression in array size\n")
				;;
				expectcsqbrac(p, "in array type")
			;;
		| _:
			tokunget(p)
			break
		;;
	;;
	-> base
}

const expectcsqbrac = {p, msg
	match toknext(p)
	| (l, `Tcsqbrac):	/* nothing */
	| (l, tok):	err(l, "expected ']' in {}, got {}\n", msg, tok)
	;;
}

const optendlns = {p
	while true
		match tokpeek(p)
		| (l, `Tendln): toknext(p)
		| _:    break
		;;
	;;
}

const endlns = {p
	match tokpeek(p)
	| (l, `Tendln): optendlns(p)
	| (l, tok):	err(l, "expected \\n, got {}\n", tok)
	;;
	-> true
}
